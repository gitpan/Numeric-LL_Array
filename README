Numeric-LL_Array version 0.01
==========================

For unsigned int/long, *_abs first converts to signed variant, then takes abs().

~, <<, >>, and % do not allow floating-point source and/or target types.

Transcendental functions are defined only with the same source type and target
types, both floating-point.

Binary operations are defined only for target type being one of the source types.

Dot product operation: targ += s1 * s2.

NEED: accessors, > (with casts?), == etc, cmp()
NEED: product with wider target; same for lshift...
	(need src casts...)
NEED: ceil, floor, trunc, rint, modf, ldexp, frexp (all take *l), cbrt...
NEED: how to access long double, long long?
NEED: min/max ???
NEED: How to find first elt which breaks conditions (as in a[n+1] == a[n]+1???
NEED: more intelligent choice of accessors for q/Q...
NEED: remove duplicate flavors for commutative 2-arg operations...
NEED: make methods static

DONE: skip duplicate sizes (such as int/long may be)...
DONE: skip duplicate commutative (first size never larger than the second)...

INSTALLATION

To install this module type the following:

   perl Makefile.PL
   make
   make test
   make install

DEPENDENCIES

None.

COPYRIGHT AND LICENCE

Copyright (C) 2009 by Ilya Zakharevich

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.2 or,
at your option, any later version of Perl 5 you may have available.



========================================================

One of the principal overheads of using Perl for numeric vector calculations
is the need to constantly create and destroy a large amount of Perl values
(this need is not present in calculations over scalars, since Perl knows how
to reuse implicit temporary variables).

Thus, in this package, we provide a way to manipulate vectors "in place"
without creation of new Perl values.  Additionally, the calculations over
slots in a vector are performed in C, thus significantly reducing overhead
of Perl over C.

One of the design goals is that many vectors should be able to use the
same C array of type double[] (possibly with offset and a stride), so over a
subarray does not require a new allocation.  The C array is stored in
PVX of a Perl variable, so it may be refcounted in the usual Perlish way.

(Future; currently very low-level) Layout of an object:
   RV:		double[]
   IV:		(IV)pointer to sub-array descriptor:
			struct { STRLEN start;
				 I32    dim;
				 struct { I32 size, stride} [dim]; };

(may also need total amount of elements, and total amount of elements in
all subarrays...)
